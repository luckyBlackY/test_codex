<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D OXã‚²ãƒ¼ãƒ </title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: white;
            overflow: hidden;
        }
        
        .ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        h1 {
            margin: 0 0 15px 0;
            color: #00d4ff;
            font-size: 1.8em;
            text-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
        }
        
        .status {
            font-size: 1.2em;
            margin-bottom: 15px;
            font-weight: bold;
            color: #ffffff;
            min-height: 25px;
        }
        
        .controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .reset-btn {
            background: linear-gradient(135deg, #ff6b6b, #ff8e53);
            color: white;
            border: none;
            padding: 12px 25px;
            font-size: 1em;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
        }
        
        .reset-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(255, 107, 107, 0.3);
        }
        
        .info {
            font-size: 0.9em;
            color: #a0a0a0;
            margin-top: 15px;
            line-height: 1.4;
        }
        
        .winner {
            animation: glow 1s ease-in-out infinite alternate;
        }
        
        @keyframes glow {
            from { text-shadow: 0 0 5px #00d4ff; }
            to { text-shadow: 0 0 20px #00d4ff, 0 0 30px #00d4ff; }
        }
        
        #gameCanvas {
            display: block;
            cursor: grab;
        }
        
        #gameCanvas:active {
            cursor: grabbing;
        }
    </style>
</head>
<body>
    <div class="ui-container">
        <h1>3D OXã‚²ãƒ¼ãƒ </h1>
        <div id="status" class="status">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ O ã®ç•ªã§ã™</div>
        <div class="controls">
            <button id="resetBtn" class="reset-btn">ãƒªã‚»ãƒƒãƒˆ</button>
        </div>
        <div class="info">
            ğŸ–±ï¸ ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦å›è»¢<br>
            ğŸ¯ ã‚»ãƒ«ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦é…ç½®<br>
            ğŸ“¦ 27å€‹ã®ã‚»ãƒ«ã§å‹åˆ©ã‚’ç›®æŒ‡ãã†ï¼
        </div>
    </div>
    
    <canvas id="gameCanvas"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        class TicTacToe3D {
            constructor() {
                this.board = Array(27).fill('');
                this.currentPlayer = 'O';
                this.gameActive = true;
                this.statusElement = document.getElementById('status');
                this.resetBtn = document.getElementById('resetBtn');
                this.winPatterns = this.generateWinPatterns();
                
                // Three.js setup
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ 
                    canvas: document.getElementById('gameCanvas'),
                    antialias: true,
                    alpha: true
                });
                
                this.cells = [];
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                this.isMouseDown = false;
                this.mouseStart = new THREE.Vector2();
                this.rotation = new THREE.Vector2();
                
                this.init();
            }
            
            generateWinPatterns() {
                const patterns = [];
                
                // å„å±¤ã§ã®è¡Œãƒ»åˆ—ãƒ»å¯¾è§’ç·š
                for (let z = 0; z < 3; z++) {
                    // è¡Œ
                    for (let y = 0; y < 3; y++) {
                        patterns.push([z * 9 + y * 3 + 0, z * 9 + y * 3 + 1, z * 9 + y * 3 + 2]);
                    }
                    // åˆ—
                    for (let x = 0; x < 3; x++) {
                        patterns.push([z * 9 + 0 * 3 + x, z * 9 + 1 * 3 + x, z * 9 + 2 * 3 + x]);
                    }
                    // å¯¾è§’ç·š
                    patterns.push([z * 9 + 0 * 3 + 0, z * 9 + 1 * 3 + 1, z * 9 + 2 * 3 + 2]);
                    patterns.push([z * 9 + 0 * 3 + 2, z * 9 + 1 * 3 + 1, z * 9 + 2 * 3 + 0]);
                }
                
                // å‚ç›´ã®åˆ—
                for (let y = 0; y < 3; y++) {
                    for (let x = 0; x < 3; x++) {
                        patterns.push([0 * 9 + y * 3 + x, 1 * 9 + y * 3 + x, 2 * 9 + y * 3 + x]);
                    }
                }
                
                // å‚ç›´ã®å¯¾è§’ç·šï¼ˆå‰å¾Œï¼‰
                for (let y = 0; y < 3; y++) {
                    patterns.push([0 * 9 + y * 3 + 0, 1 * 9 + y * 3 + 1, 2 * 9 + y * 3 + 2]);
                    patterns.push([0 * 9 + y * 3 + 2, 1 * 9 + y * 3 + 1, 2 * 9 + y * 3 + 0]);
                }
                
                // å‚ç›´ã®å¯¾è§’ç·šï¼ˆå·¦å³ï¼‰
                for (let x = 0; x < 3; x++) {
                    patterns.push([0 * 9 + 0 * 3 + x, 1 * 9 + 1 * 3 + x, 2 * 9 + 2 * 3 + x]);
                    patterns.push([0 * 9 + 2 * 3 + x, 1 * 9 + 1 * 3 + x, 2 * 9 + 0 * 3 + x]);
                }
                
                // 3Då¯¾è§’ç·šï¼ˆ4æœ¬ï¼‰
                patterns.push([0, 13, 26]); // å·¦ä¸Šå‰ â†’ ä¸­å¤® â†’ å³ä¸‹å¾Œ
                patterns.push([2, 13, 24]); // å³ä¸Šå‰ â†’ ä¸­å¤® â†’ å·¦ä¸‹å¾Œ
                patterns.push([6, 13, 20]); // å·¦ä¸‹å‰ â†’ ä¸­å¤® â†’ å³ä¸Šå¾Œ
                patterns.push([8, 13, 18]); // å³ä¸‹å‰ â†’ ä¸­å¤® â†’ å·¦ä¸Šå¾Œ
                
                return patterns;
            }
            
            init() {
                this.setupRenderer();
                this.setupCamera();
                this.setupLights();
                this.createBoard();
                this.setupEventListeners();
                this.animate();
            }
            
            setupRenderer() {
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x000000, 0);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            }
            
            setupCamera() {
                this.camera.position.set(5, 5, 5);
                this.camera.lookAt(0, 0, 0);
            }
            
            setupLights() {
                // ç’°å¢ƒå…‰
                const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
                this.scene.add(ambientLight);
                
                // æŒ‡å‘æ€§ãƒ©ã‚¤ãƒˆ
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(10, 10, 5);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                this.scene.add(directionalLight);
                
                // ãƒã‚¤ãƒ³ãƒˆãƒ©ã‚¤ãƒˆ
                const pointLight = new THREE.PointLight(0x00d4ff, 0.3, 100);
                pointLight.position.set(-5, 5, -5);
                this.scene.add(pointLight);
            }
            
            createBoard() {
                // ã‚°ãƒ«ãƒ¼ãƒ—ã‚’ä½œæˆã—ã¦ãƒœãƒ¼ãƒ‰ã‚’æ•´ç†
                this.boardGroup = new THREE.Group();
                this.scene.add(this.boardGroup);
                
                // ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã‚’ä½œæˆ
                this.createFramework();
                
                // ã‚»ãƒ«ã‚’ä½œæˆ
                for (let z = 0; z < 3; z++) {
                    for (let y = 0; y < 3; y++) {
                        for (let x = 0; x < 3; x++) {
                            const index = z * 9 + y * 3 + x;
                            this.createCell(x - 1, y - 1, z - 1, index);
                        }
                    }
                }
            }
            
            createFramework() {
                const frameGeometry = new THREE.BoxGeometry(0.05, 3.2, 0.05);
                const frameMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x333333,
                    transparent: true,
                    opacity: 0.3
                });
                
                // ã‚°ãƒªãƒƒãƒ‰ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ä½œæˆ
                for (let i = 0; i < 4; i++) {
                    for (let j = 0; j < 4; j++) {
                        // Xæ–¹å‘ã®ãƒ•ãƒ¬ãƒ¼ãƒ 
                        const frameX = new THREE.Mesh(frameGeometry, frameMaterial);
                        frameX.position.set(i - 1.5, 0, j - 1.5);
                        frameX.rotation.z = Math.PI / 2;
                        this.boardGroup.add(frameX);
                        
                        // Zæ–¹å‘ã®ãƒ•ãƒ¬ãƒ¼ãƒ 
                        const frameZ = new THREE.Mesh(frameGeometry, frameMaterial);
                        frameZ.position.set(j - 1.5, 0, i - 1.5);
                        frameZ.rotation.x = Math.PI / 2;
                        this.boardGroup.add(frameZ);
                        
                        // Yæ–¹å‘ã®ãƒ•ãƒ¬ãƒ¼ãƒ 
                        const frameY = new THREE.Mesh(frameGeometry, frameMaterial);
                        frameY.position.set(i - 1.5, j - 1.5, 0);
                        this.boardGroup.add(frameY);
                    }
                }
            }
            
            createCell(x, y, z, index) {
                const geometry = new THREE.SphereGeometry(0.3, 16, 16);
                const material = new THREE.MeshPhongMaterial({ 
                    color: 0x555555,
                    transparent: true,
                    opacity: 0.3,
                    emissive: 0x111111
                });
                
                const cell = new THREE.Mesh(geometry, material);
                cell.position.set(x, y, z);
                cell.userData = { index: index, isEmpty: true };
                cell.castShadow = true;
                cell.receiveShadow = true;
                
                this.boardGroup.add(cell);
                this.cells.push(cell);
            }
            
            setupEventListeners() {
                this.resetBtn.addEventListener('click', () => this.resetGame());
                
                const canvas = this.renderer.domElement;
                
                canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
                canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
                canvas.addEventListener('mouseup', (e) => this.onMouseUp(e));
                canvas.addEventListener('click', (e) => this.onMouseClick(e));
                
                window.addEventListener('resize', () => this.onWindowResize());
            }
            
            onMouseDown(event) {
                this.isMouseDown = true;
                this.mouseStart.x = event.clientX;
                this.mouseStart.y = event.clientY;
            }
            
            onMouseMove(event) {
                if (this.isMouseDown) {
                    const deltaX = event.clientX - this.mouseStart.x;
                    const deltaY = event.clientY - this.mouseStart.y;
                    
                    this.rotation.x += deltaY * 0.01;
                    this.rotation.y += deltaX * 0.01;
                    
                    this.boardGroup.rotation.x = this.rotation.x;
                    this.boardGroup.rotation.y = this.rotation.y;
                    
                    this.mouseStart.x = event.clientX;
                    this.mouseStart.y = event.clientY;
                }
            }
            
            onMouseUp(event) {
                this.isMouseDown = false;
            }
            
            onMouseClick(event) {
                if (!this.gameActive) return;
                
                this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObjects(this.cells);
                
                if (intersects.length > 0) {
                    const cell = intersects[0].object;
                    const index = cell.userData.index;
                    
                    if (this.board[index] === '') {
                        this.makeMove(index, cell);
                    }
                }
            }
            
            makeMove(index, cell) {
                this.board[index] = this.currentPlayer;
                cell.userData.isEmpty = false;
                
                // ã‚»ãƒ«ã®è¦‹ãŸç›®ã‚’æ›´æ–°
                this.updateCellAppearance(cell, this.currentPlayer);
                
                if (this.checkWin()) {
                    this.statusElement.textContent = `ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ ${this.currentPlayer} ã®å‹åˆ©ï¼`;
                    this.statusElement.classList.add('winner');
                    this.gameActive = false;
                    this.highlightWinningCells();
                } else if (this.checkDraw()) {
                    this.statusElement.textContent = 'å¼•ãåˆ†ã‘ï¼';
                    this.gameActive = false;
                } else {
                    this.currentPlayer = this.currentPlayer === 'O' ? 'X' : 'O';
                    this.statusElement.textContent = `ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ ${this.currentPlayer} ã®ç•ªã§ã™`;
                }
            }
            
            updateCellAppearance(cell, player) {
                if (player === 'O') {
                    // Oç”¨ã®ãƒªãƒ³ã‚°å½¢çŠ¶
                    const ringGeometry = new THREE.TorusGeometry(0.25, 0.1, 8, 16);
                    const ringMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0x00aaff,
                        emissive: 0x002244
                    });
                    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    ring.position.copy(cell.position);
                    ring.castShadow = true;
                    this.boardGroup.add(ring);
                    cell.userData.symbol = ring;
                } else {
                    // Xç”¨ã®ã‚¯ãƒ­ã‚¹å½¢çŠ¶
                    const crossGroup = new THREE.Group();
                    const barGeometry = new THREE.BoxGeometry(0.05, 0.6, 0.05);
                    const barMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0xff4444,
                        emissive: 0x441111
                    });
                    
                    const bar1 = new THREE.Mesh(barGeometry, barMaterial);
                    bar1.rotation.z = Math.PI / 4;
                    bar1.castShadow = true;
                    crossGroup.add(bar1);
                    
                    const bar2 = new THREE.Mesh(barGeometry, barMaterial);
                    bar2.rotation.z = -Math.PI / 4;
                    bar2.castShadow = true;
                    crossGroup.add(bar2);
                    
                    crossGroup.position.copy(cell.position);
                    this.boardGroup.add(crossGroup);
                    cell.userData.symbol = crossGroup;
                }
                
                // ã‚»ãƒ«è‡ªä½“ã‚’éè¡¨ç¤ºã«ã™ã‚‹
                cell.visible = false;
            }
            
            highlightWinningCells() {
                const winningPattern = this.winPatterns.find(pattern => {
                    const [a, b, c] = pattern;
                    return this.board[a] && 
                           this.board[a] === this.board[b] && 
                           this.board[a] === this.board[c];
                });
                
                if (winningPattern) {
                    winningPattern.forEach(index => {
                        const cell = this.cells[index];
                        if (cell.userData.symbol) {
                            // å‹åˆ©ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                            const originalColor = cell.userData.symbol.material ? 
                                cell.userData.symbol.material.color.clone() :
                                cell.userData.symbol.children[0].material.color.clone();
                            
                            let glowIntensity = 0;
                            const glowAnimation = () => {
                                glowIntensity += 0.1;
                                const intensity = Math.sin(glowIntensity) * 0.5 + 0.5;
                                
                                if (cell.userData.symbol.material) {
                                    cell.userData.symbol.material.emissive.setRGB(
                                        originalColor.r * intensity,
                                        originalColor.g * intensity,
                                        originalColor.b * intensity
                                    );
                                } else {
                                    cell.userData.symbol.children.forEach(child => {
                                        child.material.emissive.setRGB(
                                            originalColor.r * intensity,
                                            originalColor.g * intensity,
                                            originalColor.b * intensity
                                        );
                                    });
                                }
                                
                                if (this.gameActive === false) {
                                    requestAnimationFrame(glowAnimation);
                                }
                            };
                            glowAnimation();
                        }
                    });
                }
            }
            
            checkWin() {
                return this.winPatterns.some(pattern => {
                    const [a, b, c] = pattern;
                    return this.board[a] && 
                           this.board[a] === this.board[b] && 
                           this.board[a] === this.board[c];
                });
            }
            
            checkDraw() {
                return this.board.every(cell => cell !== '');
            }
            
            resetGame() {
                this.board = Array(27).fill('');
                this.currentPlayer = 'O';
                this.gameActive = true;
                this.statusElement.textContent = 'ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ O ã®ç•ªã§ã™';
                this.statusElement.classList.remove('winner');
                
                // ã‚·ãƒ³ãƒœãƒ«ã‚’é™¤å»
                this.cells.forEach(cell => {
                    if (cell.userData.symbol) {
                        this.boardGroup.remove(cell.userData.symbol);
                        cell.userData.symbol = null;
                    }
                    cell.userData.isEmpty = true;
                    cell.visible = true;
                });
            }
            
            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                // è‡ªå‹•å›è»¢ï¼ˆã‚†ã£ãã‚Šï¼‰
                if (!this.isMouseDown) {
                    this.boardGroup.rotation.y += 0.002;
                }
                
                this.renderer.render(this.scene, this.camera);
            }
        }
        
        // ã‚²ãƒ¼ãƒ é–‹å§‹
        document.addEventListener('DOMContentLoaded', () => {
            new TicTacToe3D();
        });
    </script>
</body>
</html>